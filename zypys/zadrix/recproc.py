"""This module processes my Minecraft recordings.

With a source directory containing recordings and a target directory, it can:

1. Compresses recordings, and move the compressed files into the target
directory.

2. Extract highlights as smaller videos, and move them into the target
directory.

3. Copy all timelapse videos generated by Replay Mod to the target directory.

This module is made with functional programming paradim.  All video manipulation
is done with FFmpeg.
"""

import csv
import datetime
import logging
import re
import shutil
import subprocess
import sys
from itertools import starmap
from pathlib import Path
from typing import Tuple

# ------------------------------------------------------------------------------
# File recognition
# ------------------------------------------------------------------------------

# Regular expression indicating a recording.
RE_RECORDING = re.compile("^[0-9]+_day[0-9]+_.*\\.(mp4|mov|mkv)$")

# Regular expression extracting index from a recording.
RE_ID = re.compile("^([0-9]+).*$")

# Regular expression indicating a timelapse video.
RE_TIMELAPSE = re.compile("^[0-9]+[a-z]+_.*\\.(mp4|mov|mkv)")


def is_recording(file: Path) -> bool:
    """Return true if file is a recoding."""
    return file.is_file() and RE_RECORDING.fullmatch(file.name) is not None


def is_timelapse(file: Path) -> bool:
    """Return true if file is a timelapse."""
    return file.is_file() and RE_TIMELAPSE.fullmatch(file.name) is not None


def get_index(file: Path) -> int:
    """Get the index of a recording or a timelapse.

    Return -1 if no index is found.
    """
    match = RE_ID.search(file.name)
    if match is None:
        return -1
    return int(match.group(1))


def get_recordings(directory: Path) -> list[Path]:
    """Get the list of recordings contained in a directory.

    Recordings are sorted with their indices.
    """
    recordings = list(filter(is_recording, directory.iterdir()))
    recordings = sorted(recordings, key=get_index)
    return recordings


def get_timelapses(directory: Path) -> list[Path]:
    """Get the list of timelapses contained in a directory."""
    return list(filter(is_timelapse, directory.iterdir()))


###############################################################################
#                                 Compressing                                 #
###############################################################################


def compress(in_file: Path, out_file: Path) -> int:
    """Compress one file with FFmpeg.

    Return the return code.
    """
    cmd = [
        "ffmpeg",
        "-i",
        str(in_file),
        "-loglevel",
        "warning",
        "-preset",
        "medium",
        "-c:v",
        "libx265",
        "-crf",
        "28",
        "-s",
        "1280x720",
        "-filter:v",
        "fps=30",
        str(out_file),
    ]
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.stdout is not None:
        for line in result.stdout.splitlines():
            print(line)
    return result.returncode


def compress_all(in_dir: Path, out_dir: Path, maxnum: int = 0) -> int:
    """Compress all recordings in in_dir, printing info.

    Compressed recordings are put into out_dir.

    Compress maxnum recordings at most.  If maxnum is 0, compress all
    recordings.

    Return 130 if interrupted, or 0 otherwise.
    """
    in_files = get_recordings(in_dir)
    out_files = list(map(lambda in_file: out_dir.joinpath(in_file.name), in_files))
    if maxnum == 0:
        maxnum = len(in_files)
    print(f"{len(in_files)} recordings found, {maxnum} recordings to compress.")
    for i, (in_file, out_file) in enumerate(zip(in_files, out_files)):
        if i >= maxnum:
            break
        # Skip if output already exist.
        if out_file.exists():
            print(f'Skip existing file "{out_file.name}".')
            continue
        # Print info without newline.
        now = datetime.datetime.now().strftime("%H:%M")
        info = f'Start compressing "{in_file.name}" at {now} ({i}/{maxnum})...'
        print(info, end="", flush=True)
        info_finished = False
        try:
            # Compress the file.
            compress(in_file, out_file)
            # Finish the info.
            print("done")
            info_finished = True
        except KeyboardInterrupt:
            # When compressing is interrupted, delete the incomplete output
            # file.
            if not info_finished:
                print("")
            print("Compressing interrupted by Ctrl-C.")
            out_file.unlink(missing_ok=True)
            return 130
    return 0


###############################################################################
#                                  Extracting                                 #
###############################################################################


def read_extract_txt(
    in_dir: Path, fname: str = "extract.txt"
) -> Tuple[list[int], list[str], list[str], list[str]]:
    """Read extract.txt, load its contents into 4 lists.

    The four lists returned are:
    index: The indices of the recordings to extract.
    start: The starting timestamps of the extraction.
    end: Tne ending timestamps of the extraction.
    title: The titles of the extracted clips.
    """
    extract_txt = in_dir.joinpath(fname)
    try:
        with open(extract_txt, newline="", encoding="utf-8") as f:
            reader = csv.reader(f, delimiter=" ")
            index: list[int] = []
            start: list[str] = []
            end: list[str] = []
            title: list[str] = []
            for line in reader:
                index.append(int(line[0]))
                start.append(line[1])
                end.append(line[2])
                title.append(line[3])
            return index, start, end, title
    except Exception:
        logging.error('Failed to read "%s".', extract_txt)
        return [], [], [], []


def extract(in_file: Path, out_file: Path, start: str, end: str) -> int:
    """Extract one file with FFmpeg.

    Arguments start and end are timestamps.

    Return the return code.
    """
    cmd = [
        "ffmpeg",
        "-i",
        str(in_file),
        "-loglevel",
        "warning",
        "-preset",
        "medium",
        "-c:v",
        "libx265",
        "-crf",
        "23",
        "-x265-params",
        "keyint=60",
        "-ss",
        start,
        "-to",
        end,
        str(out_file),
    ]
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.stdout is not None:
        for line in result.stdout.splitlines():
            print(line)
    return result.returncode


def get_extract_jobs(
    in_dir: Path, out_dir: Path
) -> Tuple[list[Path], list[Path], list[str], list[str]]:
    """Get the lists describing the extraction.

    Return several lists:
    in_files: The input files.
    out_files: The output files.
    start: The starting timestamps.
    end: The ending timestamps.
    """
    index, start, end, title = read_extract_txt(in_dir)
    recordings = get_recordings(in_dir)

    def find_recording_with_index(index: int) -> Path:
        return list(
            filter(lambda recording: get_index(recording) == index, recordings)
        )[0]

    in_files = list(map(find_recording_with_index, index))
    out_files = list(
        starmap(
            lambda i, t: out_dir.joinpath(f"clip_{i:03}_{t}.mp4"),
            zip(index, title),
        )
    )
    return in_files, out_files, start, end


def extract_all(in_dir: Path, out_dir: Path, maxnum: int = 0) -> int:
    """Extract all recordings in in_dir, printing info.

    Extracted recordings are put into out_dir.

    Extract maxnum recordings at most.  If maxnum is 0, extract all recordings.

    Return 130 if interrupted, or 0 otherwise.
    """
    in_files, out_files, start, end = get_extract_jobs(in_dir, out_dir)
    if maxnum == 0:
        maxnum = len(in_files)
    print(f"{len(in_files)} extraction jobs found, {maxnum} recordings to extract.")
    for i, (in_file, out_file, start_i, end_i) in enumerate(
        zip(in_files, out_files, start, end)
    ):
        if i >= maxnum:
            break
        # Skip if output already exist.
        if out_file.exists():
            print(f'Skip existing file "{out_file.name}".')
            continue
        # Print info without newline.
        now = datetime.datetime.now().strftime("%H:%M")
        info = f'Start extracting "{in_file.name}" at {now} ({i+1}/{maxnum})...'
        print(info, end="", flush=True)
        info_finished = False
        try:
            # Extract the file.
            extract(in_file, out_file, start_i, end_i)
            # Finish the info.
            print("done")
            info_finished = True
        except KeyboardInterrupt:
            # When extracting is interrupted, delete the incomplete output file.
            if not info_finished:
                print("")
            print("Extracting interrupted by Ctrl-C.")
            out_file.unlink(missing_ok=True)
            return 130
    return 0


###############################################################################
#                               Copy Timelapses                               #
###############################################################################


def copy(in_file: Path, out_file: Path) -> int:
    """Copy one timelapse to the destination."""
    shutil.copyfile(in_file, out_file)
    return 0


def copy_all(in_dir: Path, out_dir: Path) -> int:
    """Copy all timelapses from in_dir to out_dir, printing info.

    Return 130 if interrupted, or 0 otherwise.
    """
    in_files = get_timelapses(in_dir)
    print(f"{len(in_files)} timelapses found.")
    for in_file in in_files:
        out_file = out_dir.joinpath(in_file.name)
        try:
            copy(in_file, out_file)
        except KeyboardInterrupt:
            # When extracting is interrupted, delete the incomplete output file.
            print("Copying interrupted by Ctrl-C.")
            out_file.unlink(missing_ok=True)
            return 130
    print(f"{len(in_files)} timelapses copied.")
    return 0


###############################################################################
#                            Command Line Interface                           #
###############################################################################


def cli():
    """Command line interface of this module."""
    import argparse

    # Parse arguments.
    parser = argparse.ArgumentParser(
        description="Post-processor for Zadrix recordings and timelapses."
    )
    parser.add_argument(
        "dir",
        type=str,
        default=".",
        nargs="?",
        help="directory where recordings reside.",
    )
    parser.add_argument(
        "outdir",
        type=str,
        default="",
        nargs="?",
        help='directory to place result videos, defaults to "<dir>_archives"',
    )
    parser.add_argument(
        "--maxnum",
        type=int,
        default=0,
        help="maximum number of recordings to compress/extract",
    )
    args = parser.parse_args()

    # Validate input and output directory.
    in_dir = Path(args.dir).absolute()
    if not in_dir.is_dir():
        print(f'"{in_dir}" is not a valid directory.')
        return 1
    if args.outdir:
        out_dir = Path(args.outdir).absolute()
    else:
        out_dir_name = in_dir.name + "_archives"
        out_dir = in_dir.parent.joinpath(out_dir_name)
    if not out_dir.is_dir():
        if out_dir.is_file():
            print(f'Output directory "{out_dir}" is a file!')
            return 1
        try:
            out_dir.mkdir()
            print(f'Output directory "{out_dir}" created.')
        except Exception as e:
            print(e)
            return 1

    # Copy, compress and extract.
    if copy_all(in_dir, out_dir) == 130:
        return 130
    if compress_all(in_dir, out_dir, maxnum=args.maxnum) == 130:
        return 130
    if extract_all(in_dir, out_dir, maxnum=args.maxnum) == 130:
        return 130
    return 0


if __name__ == "__main__":
    # Run the command line interface when called from command line, or some
    # random script to play with if called interactively in a REPL.
    if not hasattr(sys, "ps1"):
        cli()
    else:
        pass
